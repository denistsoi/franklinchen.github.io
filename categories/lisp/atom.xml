<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lisp on Franklin Chen</title>
    <link>http://franklinchen.com/categories/lisp/atom/index.xml</link>
    <description>Recent content in Lisp on Franklin Chen</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://franklinchen.com/categories/lisp/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My first Pittsburgh Clojure Meetup: Ambrose Bonnaire-Sergeant on core.logic</title>
      <link>http://franklinchen.com/blog/2011/11/15/my-first-pittsburgh-clojure-meetup-ambrose-bonnaire-sergeant-on-core-logic/</link>
      <pubDate>Tue, 15 Nov 2011 23:12:00 +0000</pubDate>
      
      <guid>http://franklinchen.com/blog/2011/11/15/my-first-pittsburgh-clojure-meetup-ambrose-bonnaire-sergeant-on-core-logic/</guid>
      <description>&lt;p&gt;I finally attended a &lt;a href=&#34;http://www.meetup.com/Clojure-PGH/events/16249445/&#34;&gt;meeting&lt;/a&gt; of the local &lt;a href=&#34;http://www.meetup.com/Clojure-PGH/&#34;&gt;Pittsburgh Clojure meetup&lt;/a&gt; group, for the first time!&lt;/p&gt;

&lt;p&gt;I came to this meeting largely because I heard that Ambrose Bonnaire-Sergeant, a student in Australia, was visiting the US &lt;a href=&#34;http://cemerick.com/2011/11/08/ambrose-has-received-his-clojure-scholarship-thanks-to-you/&#34;&gt;on scholarship&lt;/a&gt; to present at &lt;a href=&#34;https://github.com/relevance/clojure-conj/tree/master/2011-slides&#34;&gt;Clojure/Conj&lt;/a&gt; and was happening to be in town in Pittsburgh, and therefore was going to visit the Pittsburgh Clojure meetup group and talk about his recent work on logic programming.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-note-on-clojure&#34;&gt;A note on Clojure&lt;/h2&gt;

&lt;p&gt;I confess I haven&amp;rsquo;t yet done anything with the Clojure language.&lt;/p&gt;

&lt;p&gt;However, two decades ago, back in the 1990s, I spent a lot of time programming in Scheme, another Lisp variant, and I also did a tiny bit of programming in Common Lisp (but when I discovered Scheme, I basically lost all interest in Common Lisp).&lt;/p&gt;

&lt;p&gt;It is remarkable to me that a Lisp has become revived again recently, because for decades it was always such a niche language. Probably most of us who have used Lisp at all have done so through Emacs, which is configured using Emacs Lisp. I&amp;rsquo;m pretty excited about the Lisp revival, despite my having my own reasons not to prefer Lisp right now for my own programming.&lt;/p&gt;

&lt;h2 id=&#34;ambrose-s-presentation&#34;&gt;Ambrose&amp;rsquo;s presentation&lt;/h2&gt;

&lt;p&gt;I got lost during Ambrose&amp;rsquo;s presentation since the logic programming library &lt;a href=&#34;https://github.com/clojure/core.logic&#34;&gt;&lt;code&gt;core.logic&lt;/code&gt;&lt;/a&gt; is an embedded domain-specific language with its own look. One of the advantages of Lisp is that macros enable creating domain-specific languages; of course, this is also a disadvantage. If I wanted to understand &lt;code&gt;core.logic&lt;/code&gt;, I would have to go off on my own and study it and play around with it and probably even study its implementation.&lt;/p&gt;

&lt;p&gt;This is how I felt also last month when I went to a &lt;a href=&#34;../../blog/2011/10/06/pittsburgh-ruby-building-a-compiler-in-jruby/&#34;&gt;Ruby meetup that also involved domain-specific languages&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Seeing the inventor of the abstract data type</title>
      <link>http://franklinchen.com/blog/2011/11/10/seeing-the-inventor-of-the-abstract-data-type/</link>
      <pubDate>Thu, 10 Nov 2011 18:54:00 +0000</pubDate>
      
      <guid>http://franklinchen.com/blog/2011/11/10/seeing-the-inventor-of-the-abstract-data-type/</guid>
      <description>&lt;p&gt;&lt;em&gt;(Important update added to the end of this post.)&lt;/em&gt;&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../../images/liskov/power-of-abstraction.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Barbara Liskov accepting Katayanagi Prize at CMU&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;&lt;a href=&#34;http://events.web.cmu.edu/ecal/event/131972213534041859&#34;&gt;Today at CMU&lt;/a&gt;, I finally had the opportunity to see a living legend, &lt;a href=&#34;http://en.wikipedia.org/wiki/Barbara_Liskov&#34;&gt;Barbara Liskov&lt;/a&gt;, computer science professor at MIT and winner of the &lt;a href=&#34;http://en.wikipedia.org/wiki/Turing_Award&#34;&gt;Turing Award&lt;/a&gt; in 2008. She won it largely for her invention of the &lt;a href=&#34;http://en.wikipedia.org/wiki/Abstract_data_type&#34;&gt;abstract data type&lt;/a&gt;, a concept that is so foundational in modern software development that a programmer ignorant of history is likely to react, &amp;ldquo;What, she got a Turing Award for something so obvious?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s the beauty of computer science: it is such a young field that many of the ideas we take for granted now were &lt;em&gt;not&lt;/em&gt; so obvious decades ago, and had to be discovered and codified and explained.&lt;/p&gt;

&lt;p&gt;I had to leave Liskov&amp;rsquo;s talk right after she was done (it had already run over time), so I missed the question-and-answer session, unfortunately. I had been considering asking some questions, but since I lost that opportunity, I will pose them here instead.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-invention-of-the-abstract-data-type&#34;&gt;The invention of the abstract data type&lt;/h2&gt;

&lt;p&gt;Basically, Liskov formalized the notion of the abstract data type (ADT) while at MIT in the early 1970s, and with some graduate students implemented ADTs as a fundamental construct in an actual programming language, &lt;a href=&#34;http://en.wikipedia.org/wiki/CLU_(programming_language)&#34;&gt;CLU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Most of you probably haven&amp;rsquo;t heard of CLU, unless you went to &lt;a href=&#34;http://www.pmg.csail.mit.edu/CLU.html&#34;&gt;MIT&lt;/a&gt; where it&amp;rsquo;s been used for ages in courses. I only know about CLU because a long time ago, I had an MIT friend who mentioned CLU when I was asking him &lt;a href=&#34;../../blog/2011/10/25/rip-john-mccarthy-but-lisp-will-never-die/&#34;&gt;what to learn to become a programmer&lt;/a&gt;. I never actually wrote or ran a program in CLU, although I did take a look at the language. Some features of CLU (recall that it was developed in the early 1970s):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;modules (called &amp;ldquo;clusters&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;information hiding&lt;/li&gt;
&lt;li&gt;static typing, including what are now called generics&lt;/li&gt;
&lt;li&gt;iterators (what we now usually call &lt;a href=&#34;http://en.wikipedia.org/wiki/Generator_%28computer_science%29&#34;&gt;generators&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;exception handling&lt;/li&gt;
&lt;li&gt;garbage collection&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Think about it. Java, developed &lt;em&gt;two decades&lt;/em&gt; after CLU, didn&amp;rsquo;t even have generics. And it does not have true iterators.&lt;/p&gt;

&lt;h3 id=&#34;a-tangent-on-technology-adoption&#34;&gt;A tangent on technology adoption&lt;/h3&gt;

&lt;p&gt;If you are in industry, a lesson to take away is that there is probably computer science research in academia &lt;em&gt;right now&lt;/em&gt; that is useful but you won&amp;rsquo;t be using for twenty or thirty years.&lt;/p&gt;

&lt;p&gt;If you are in academia, you might want to consider helping get good technology out the door before industry wastes two or three decades flailing around using inferior or broken ideas. (In fact, Liskov in her talk today noted that she had considered commercializing CLU.)&lt;/p&gt;

&lt;h3 id=&#34;influence-on-other-languages&#34;&gt;Influence on other languages&lt;/h3&gt;

&lt;p&gt;Liskov chose in her initial work to focus on data abstraction, rather than unify that with object-orientation, which had begun being implemented in the 1960s by &lt;a href=&#34;http://en.wikipedia.org/wiki/Simula&#34;&gt;Simula&lt;/a&gt;, but later contributed to the understanding of &lt;a href=&#34;http://en.wikipedia.org/wiki/Liskov_substitution_principle&#34;&gt;subtyping&lt;/a&gt; in object-oriented languages.&lt;/p&gt;

&lt;p&gt;C++ took templates and exceptions from CLU. (Java, of course, took them from C++.)&lt;/p&gt;

&lt;p&gt;Python, Ruby and other newer languages include iterators. To clarify: C++ and Java have &amp;ldquo;iterators&amp;rdquo; of a much different variety, which are just ordinary objects that have been implemented in often a convoluted way to maintain state for iterating through another object. The &amp;ldquo;real&amp;rdquo; iterators operate in conjunction with a special language construct usually called &lt;code&gt;yield&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;questions-i-have&#34;&gt;Questions I have&lt;/h2&gt;

&lt;p&gt;The world is globalized and connected now much more than it was back in the 1970s. So sometimes I wonder, what if it had been more connected in the past?&lt;/p&gt;

&lt;h3 id=&#34;the-c-world&#34;&gt;The C world&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/C_(programming_language)&#34;&gt;C&lt;/a&gt; was developed between 1969 and 1973.  &lt;a href=&#34;../../blog/2011/10/13/why-dennis-ritchie-is-important/&#34;&gt;Dennis Ritchie&lt;/a&gt; wrote a little article, &lt;a href=&#34;https://www.bell-labs.com/usr/dmr/www/chist.html&#34;&gt;&amp;ldquo;The Development of the C Language&amp;rdquo;&lt;/a&gt;, in which he acknowledged the debt to Fortran and Algol. However, its goal as a low-level language for implementing Unix meant that it cut various corners. I wonder if the history of computing would have been different had there been more attention paid, even in the constrained context of Unix implementation, to interesting academic work. I don&amp;rsquo;t know what Ritchie and Thompson and others knew, if anything, about the work on modularity, types, etc. Maybe they knew, but didn&amp;rsquo;t care because they were building something just for themselves and they were such good programmers they didn&amp;rsquo;t need any help writing great code. It would be interesting, as a matter of historical record, to know who knew what and thought what, when.&lt;/p&gt;

&lt;h3 id=&#34;the-functional-programming-world&#34;&gt;The functional programming world&lt;/h3&gt;

&lt;p&gt;Absent from Liskov&amp;rsquo;s talk was any mention of the functional programming world.  &lt;a href=&#34;http://en.wikipedia.org/wiki/ML_programming_language&#34;&gt;ML&lt;/a&gt; came on the scene also in the 1970s. Later, &lt;a href=&#34;http://en.wikipedia.org/wiki/Standard_ML&#34;&gt;Standard ML&lt;/a&gt; came along. I don&amp;rsquo;t know the details of the exact chronology, but Standard ML had polymorphism and exceptions right off the bat, and a module system added on top of that.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Liskov&amp;rsquo;s talk involved a lot of tracing of the history of ideas that led to her contributions.&lt;/p&gt;

&lt;p&gt;I am very curious about what influenced what, in the entire space of the history of programming languages. Obviously, a lot of ideas were floating around in the 1960s, 1970s, and 1980s, so it&amp;rsquo;s possible that many programming language features were invented independently from the same pool of rough ideas.&lt;/p&gt;

&lt;p&gt;Sometimes I wonder whether continual reinvention could be minimized, by more sharing and awareness. Even today there is a proliferation of languages, many of which were or are invented by some individual who is not aware of the full history or rigorous achievements in the area of programming language semantics or design, and therefore perpetuate problems that for decades already we have known to avoid. I wonder if this situation is really inevitable.&lt;/p&gt;

&lt;p&gt;Of course, the question might be moot, because it is always possible that human beings will simply make radically different choices, even when they are fully aware of all the ideas that are around at any given time.&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s the next step? What will we using doing twenty years from now that is currently already brewing in a university or other research lab &lt;em&gt;right now&lt;/em&gt;? From my point of view, the most interesting work being done right now is that focused on going beyond the currently most powerful statically typed languages (such as ML, Haskell, Scala) to &lt;a href=&#34;http://en.wikipedia.org/wiki/Dependent_type&#34;&gt;dependently typed languages&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;update&#34;&gt;(Update)&lt;/h2&gt;

&lt;p&gt;I have been told that it is misleading to describe Liskov as &amp;ldquo;the inventor of the abstract data type&amp;rdquo;. I admit this was a terrible title for my talk report. The content of my report should make it clear that I was baffled by Liskov&amp;rsquo;s omission of entire lines of research from the 1970s that address data abstraction, whether through ML or John Reynolds&amp;rsquo; work. See &lt;a href=&#34;http://franklinchen.com/blog/2011/11/10/seeing-the-inventor-of-the-abstract-data-type/#comment-361232515&#34;&gt;Bob Harper&amp;rsquo;s Disqus comment here&lt;/a&gt; for his own elaborations.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RIP, John McCarthy; but Lisp will never die</title>
      <link>http://franklinchen.com/blog/2011/10/25/rip-john-mccarthy-but-lisp-will-never-die/</link>
      <pubDate>Tue, 25 Oct 2011 00:14:00 +0000</pubDate>
      
      <guid>http://franklinchen.com/blog/2011/10/25/rip-john-mccarthy-but-lisp-will-never-die/</guid>
      <description>&lt;p&gt;&lt;strong&gt;(Updated 2012-01-16)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The legendary computer scientist &lt;a href=&#34;http://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)&#34;&gt;John McCarthy&lt;/a&gt; died yesterday. So there goes another guy without whom my life today would be unimaginably different: &lt;a href=&#34;../../blog/2011/10/05/i-cannot-imagine-my-life-without-the-influence-of-steve-jobs/&#34;&gt;Steve Jobs&lt;/a&gt; and &lt;a href=&#34;../../blog/2011/10/13/why-dennis-ritchie-is-important/&#34;&gt;Dennis Ritchie&lt;/a&gt; just left us this month!&lt;/p&gt;

&lt;p&gt;In a way, more than Jobs, and more than Ritchie, McCarthy indirectly got me taking seriously the whole field of computing, and actually loving it.&lt;/p&gt;

&lt;p&gt;Because I &lt;em&gt;never for a moment&lt;/em&gt; enjoyed computer programming until I discovered &lt;a href=&#34;http://en.wikipedia.org/wiki/Lisp_(programming_language)&#34;&gt;Lisp&lt;/a&gt;, the programming language that McCarthy invented and what he will surely be most remembered for most, among his other contributions to computer science.&lt;/p&gt;

&lt;p&gt;My story of love and hate in computer programming:&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;i-hate-programming&#34;&gt;I hate programming&lt;/h2&gt;

&lt;p&gt;I had finished my junior year of high school and was away from home for the first time in my life, attending the &lt;a href=&#34;http://www.cee.org/programs/rsi&#34;&gt;Research Science Institute&lt;/a&gt;(RSI), a free summer science program. There, I encountered a lot of very smart and already accomplished peers.&lt;/p&gt;

&lt;p&gt;A new friend I made at the science program was into artificial intelligence (AI) (a term coined by John McCarthy, in fact), and programming in Lisp and Prolog. He ended up doing his summer project on expert systems. He had the books on &lt;a href=&#34;http://www.amazon.com/Artificial-Intelligence-Addison-Wesley-computer-science/dp/0201084546&#34;&gt;AI&lt;/a&gt; and &lt;a href=&#34;http://www.amazon.com/LISP-Patrick-Henry-Winston/dp/0201083728&#34;&gt;Lisp&lt;/a&gt; by Patrick Winston, and he and others raved about a book by &lt;a href=&#34;http://en.wikipedia.org/wiki/Douglas_Hofstadter&#34;&gt;Doug Hofstadter&lt;/a&gt; called &lt;a href=&#34;http://en.wikipedia.org/wiki/Gödel,_Escher,_Bach&#34;&gt;&lt;em&gt;Gödel, Escher, Bach&lt;/em&gt;&lt;/a&gt;(GEB). None of the books made any sense to me at the time, but I made a note to look them up after the summer.&lt;/p&gt;

&lt;p&gt;Myself, I had gone to the program with vague ideas of doing something related to physics. I got assigned to work at the United States Geological Survey (USGS) under Allan Tanner. I was profoundly disappointed to find that I was assigned to write FORTRAN or something to control a plotter, because at this point in my life, I &lt;em&gt;hated&lt;/em&gt; computer programming!! I asked to do something else, and ended up digging holes in the ground to measure radon availability. I didn&amp;rsquo;t feel I accomplished anything really all summer, but was thanked in a paper he wrote later.&lt;/p&gt;

&lt;p&gt;Wait, so I was interested in Lisp but hated programming? What was going on?&lt;/p&gt;

&lt;p&gt;The science program had apparently thought I was interested in programming because I had just completed an Advanced Placement course in computer science in high school. It was a course based on Pascal. I left the course rather uninterested in programming. We learned about arrays, linked lists, hash tables, trees, searching, sorting, etc., and it was all very dry and abstract. The course was my least favorite of my junior year in high school. Before this course, I had been exposed to BASIC, COBOL, and FORTRAN, and these were even less appealing to me. So I had the picture of computing as drudgery for doing numerical calculations and generating reports.&lt;/p&gt;

&lt;p&gt;Lisp seemed different. It didn&amp;rsquo;t even seem like &amp;ldquo;programming&amp;rdquo; in the same sense. I saw my peers firing up the Golden Common Lisp REPL on PCs and &lt;em&gt;interacting&lt;/em&gt; with data, creating lists, using atoms, doing &lt;em&gt;symbolic&lt;/em&gt; computation easily. At the time, I could not even make the connection between this kind of programming and anything I had learned in my Pascal-based high school course. There, linked lists took a lot to implement, and we learned about &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;dispose&lt;/code&gt; and pointers. The effort to learn all this low-level stuff resulted in my never seeing from the course what much higher-level applications could be built on top.&lt;/p&gt;

&lt;h2 id=&#34;again-i-still-hate-programming&#34;&gt;Again, I still hate programming&lt;/h2&gt;

&lt;p&gt;Anyway, after I returned home, I started teaching myself Lisp, but didn&amp;rsquo;t get very far because a new interest overrode all others. This despite my also new interest in Lisp and AI, reading GEB and even having Doug Hofstadter autograph my copy of &lt;a href=&#34;http://en.wikipedia.org/wiki/Metamagical_Themas&#34;&gt;&lt;em&gt;Metamagical Themas&lt;/em&gt;&lt;/a&gt;, which had cute Lisp interludes.&lt;/p&gt;

&lt;p&gt;At the science program I had heard peers raving about the &lt;a href=&#34;http://www.feynmanlectures.info/&#34;&gt;Feynman Lectures on Physics&lt;/a&gt;. To make a long story short, after returning home, I read as far as I could before my senior year in high school began, I fell in love with physics, took Advanced Placement physics, and ended up going to college majoring in physics.&lt;/p&gt;

&lt;p&gt;Actually, freshman year in college, I considered taking the introductory computer science sequence, since a lot of my new friends (as well as friends I made at the Research Science Institute over a year earlier) did, but although the second semester involved cool-sounding Lisp projects, the first semester involved a language called &lt;a href=&#34;../../blog/2011/10/13/why-dennis-ritchie-is-important/&#34;&gt;C&lt;/a&gt;. Taking a quick look at Kernighan and Ritchie&amp;rsquo;s book, and the first homework assignment, I bailed out. The language looked like noise to me. It seemed worse than Pascal, far worse. As a result, I never took a computer science course as an undergraduate in college at all!&lt;/p&gt;

&lt;h2 id=&#34;i-love-programming&#34;&gt;I love programming&lt;/h2&gt;

&lt;p&gt;My physics journey ended in disaster. By my junior year, I was questioning the viability of my goal, in theoretical high energy physics, of working toward the &amp;ldquo;theory of everything&amp;rdquo;. String theory was getting popular, but I had no faith in it as a viable research program. I finished out my degree, and continued on to grad school hoping to do something else, but by the time I arrived, I had actually lost all interest in physics already. So I left after a year.&lt;/p&gt;

&lt;p&gt;What next?&lt;/p&gt;

&lt;p&gt;I needed to learn something else and find a job. I thought back to computer programming, especially since I was very excited about what Macs could do.  A friend of mine who had attended MIT recommended that I pick up &lt;a href=&#34;http://mitpress.mit.edu/sicp/&#34;&gt;&lt;em&gt;The Structure and Interpretation of Computer Programs&lt;/em&gt;&lt;/a&gt;(SICP) to really learn programming, before tackling C.  So I did.  This book used Lisp, or more precisely, MIT Scheme, a variant of Lisp. I got a used Mac SE/30, a free Scheme interpreter (Gambit, I think), and worked through the book.&lt;/p&gt;

&lt;p&gt;Reading SICP was one of the most profound experiences of my entire life. A full review would require its own article. In any case, it made me love and understand programming, for the first time, really.&lt;/p&gt;

&lt;p&gt;I can imagine books similar to SICP using more recent, sophisticated, statically typed languages such as ML, Haskell, or Scala, but the exposition would require more careful design, because Lisp&amp;rsquo;s macros and its &amp;ldquo;pun&amp;rdquo; of using S-expression syntax to represent abstract syntax make a lot of things easier.&lt;/p&gt;

&lt;p&gt;(I did then go learn C and C++ and find a job. Later discovering ML and Haskell and loving programming even more, and continuing on from there to the present is many more stories.)&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Lisp is a very old language, half a century old, and I happen not to use it much these days (because given a choice, I prefer static types, I prefer syntactic sugar, and I dislike parentheses), but I predict it will survive forever, because the core is so elegant and self-contained.&lt;/p&gt;

&lt;p&gt;Thank you, John McCarthy!&lt;/p&gt;

&lt;h2 id=&#34;update-2012-01-16&#34;&gt;&lt;strong&gt;Update 2012-01-16&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;I wrote a companion post on &lt;a href=&#34;../../blog/2012/01/16/how-school-made-me-hate-computer-science-and-programming/&#34;&gt;my K-12 experiences with computing education&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A near contemporary of mine, Natasha Chen (no relation), wrote an &lt;a href=&#34;http://www.eimacs.com/blog/2011/12/learn-computer-programming-without-complicated-syntax/&#34;&gt;article in 1992 on her experiences with computing education&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>