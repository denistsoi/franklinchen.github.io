<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Functional Programming on Franklin Chen</title>
    <link>http://franklinchen.com/categories/functional-programming/atom/index.xml</link>
    <description>Recent content in Functional Programming on Franklin Chen</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://franklinchen.com/categories/functional-programming/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Review of Coursera&#39;s Fall 2012 &#34;Functional Programming Principles in Scala&#34;</title>
      <link>http://franklinchen.com/blog/2012/11/15/review-of-courseras-fall-2012-functional-programming-principles-in-scala/</link>
      <pubDate>Thu, 15 Nov 2012 21:27:00 +0000</pubDate>
      
      <guid>http://franklinchen.com/blog/2012/11/15/review-of-courseras-fall-2012-functional-programming-principles-in-scala/</guid>
      <description>&lt;figure &gt;
    
        &lt;img src=&#34;http://www.scala-lang.org/sites/default/files/newsflash_logo.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;In fall of 2012, I completed the initial offering, through &lt;a href=&#34;http://www.coursera.org/&#34;&gt;Coursera&lt;/a&gt;, of &lt;a href=&#34;http://lampwww.epfl.ch/~odersky/&#34;&gt;Martin Odersky&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;http://www.coursera.org/course/progfun&#34;&gt;&amp;ldquo;Functional Programming Principles in Scala&amp;rdquo; online course&lt;/a&gt;, which was held from September 18 through November.&lt;/p&gt;

&lt;p&gt;This is a review of the course, which is planned to be offered again (so those of you who missed it the first time can sign up for the second iteration when it is available).&lt;/p&gt;

&lt;p&gt;Also check out the &lt;a href=&#34;http://docs.scala-lang.org/news/functional-programming-principles-in-scala-impressions-and-statistics.html&#34;&gt;instructor report&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-purpose-of-the-course&#34;&gt;The purpose of the course&lt;/h2&gt;

&lt;p&gt;I have noticed very often that people learning to program or to perform some task that involves programming are very fixated on the question of &amp;ldquo;what computer language should I use?&amp;rdquo; or &amp;ldquo;what computer language is the course/project going to use?&amp;rdquo; This is a mistake because what is important in learning programming or getting better at it is not trivial questions of syntax, but matters of &lt;em&gt;understanding&lt;/em&gt; what things mean and having a correct mental model of what is going on. In the end, one has to go back to fundamentals.&lt;/p&gt;

&lt;p&gt;So although this course has &amp;ldquo;Scala&amp;rdquo; in its title, it is really a brief introduction to functional programming, using &lt;a href=&#34;http://www.scala-lang.org/&#34;&gt;Scala&lt;/a&gt; as one of many possible languages in which to express it.&lt;/p&gt;

&lt;h2 id=&#34;my-background-in-computer-science-and-functional-programming&#34;&gt;My background in computer science and functional programming&lt;/h2&gt;

&lt;p&gt;I am a college graduate with a physics degree who &lt;em&gt;never took a single computer science or programming course in college&lt;/em&gt;, because I found programming to be strange, difficult, and scary, based on &lt;a href=&#34;../../blog/2012/01/16/how-school-made-me-hate-computer-science-and-programming/&#34;&gt;my experiences before college&lt;/a&gt;. I did not take up programming seriously until after college, when I found myself wanting a career change, and took a second look at computer programming.&lt;/p&gt;

&lt;p&gt;As I have mentioned earlier, a &lt;a href=&#34;../../blog/2011/10/25/rip-john-mccarthy-but-lisp-will-never-die/&#34;&gt;turning point in my life&lt;/a&gt; was when a friend recommended to me that I focus not on &amp;ldquo;learning&amp;rdquo; some arbitrary computer language, but on learning the &lt;em&gt;principles&lt;/em&gt; of programming first, after which any specific language could be understood quickly in light of the principles.&lt;/p&gt;

&lt;p&gt;So I learned functional programming through working through &lt;a href=&#34;http://mitpress.mit.edu/sicp/&#34;&gt;The Structure and Interpretation of Computer Programs&lt;/a&gt;, coding up my solutions to the exercises using &lt;a href=&#34;http://gambitscheme.org/&#34;&gt;Gambit Scheme&lt;/a&gt; on a &lt;a href=&#34;http://en.wikipedia.org/wiki/Macintosh_Classic&#34;&gt;Macintosh Classic&lt;/a&gt;. I then learned C and C++ and got my first job as a software engineer.&lt;/p&gt;

&lt;p&gt;The next big jump for me came when I encountered my first statically typed functional languages in around 1995: &lt;a href=&#34;http://caml.inria.fr/caml-light/index.en.html&#34;&gt;Caml Light&lt;/a&gt; and &lt;a href=&#34;http://www.smlnj.org/&#34;&gt;Standard ML&lt;/a&gt; and &lt;a href=&#34;http://www.haskell.org/&#34;&gt;Haskell&lt;/a&gt; through &lt;a href=&#34;http://www.haskell.org/hugs/&#34;&gt;Gofer/Hugs&lt;/a&gt;. I was so inspired by the possibilities of &lt;em&gt;improving the programming experience&lt;/em&gt; that I decided to leave my job and apply for graduate school in computer science.&lt;/p&gt;

&lt;p&gt;I was in the &lt;a href=&#34;http://www.csd.cs.cmu.edu/education/phd/&#34;&gt;Carnegie Mellon University CS PhD program&lt;/a&gt; for two years before leaving after 1999. I left for a combination of different reasons, but I am definitely still a believer in the original mission I had before going to graduate school: improving the experience of practical software development by every means necessary.&lt;/p&gt;

&lt;h2 id=&#34;my-plan-overcome-resistance-to-scala&#34;&gt;My plan: overcome resistance to Scala&lt;/h2&gt;

&lt;p&gt;Ironically, what I planned to get out of the course is &lt;em&gt;not&lt;/em&gt; what I expect most students in the course would or &lt;em&gt;should&lt;/em&gt; get out of it! I treated the course as a way to get myself to force myself to use and really learn the Scala language (since I did not need an introduction to functional programming), by solving programming exercises that I probably had done in the past in other languages.&lt;/p&gt;

&lt;p&gt;Scala had been around for years, but I had resisted doing much with it because it seemed very complex and changing all the time and because the tool ecosystem seemed to be immature and not usable for me. That led me to my not investing in the effort to truly read up on it and experiment to use at work.&lt;/p&gt;

&lt;p&gt;I am happy to report that Scala is actually usable now and all my concerns about it are no longer relevant. 2012 seems to me to be the year when Scala became truly usable for general production. (I will report later on my current plans in motion to migrate from Java to Scala at work.)&lt;/p&gt;

&lt;h2 id=&#34;observations-about-the-course&#34;&gt;Observations about the course&lt;/h2&gt;

&lt;h3 id=&#34;installation-of-software&#34;&gt;Installation of software&lt;/h3&gt;

&lt;p&gt;There were initially some glitches when setting up &lt;a href=&#34;http://eclipse.org/&#34;&gt;Eclipse&lt;/a&gt; and &lt;a href=&#34;http://www.scala-sbt.org/&#34;&gt;SBT&lt;/a&gt;, but eventually, an Eclipse distribution made specifically for the class was made available and solved my problems.&lt;/p&gt;

&lt;p&gt;That said, I preferred to use Emacs and SBT for writing code for the course.&lt;/p&gt;

&lt;h3 id=&#34;theoretical-material&#34;&gt;Theoretical material&lt;/h3&gt;

&lt;p&gt;Martin Odersky&amp;rsquo;s lectures were entirely as one would expect in a basic academic course on programming language principles: laying the fundamental mathematical groundwork: operational semantics, structural induction, etc.&lt;/p&gt;

&lt;p&gt;This material can be very dry and abstract, and I have to wonder how many students encountering it for the first time slog through long lectures of this kind of content. Personally, if I were teaching these ideas, I would use less of the typical &amp;ldquo;mathematical&amp;rdquo; kind of example when illustrating them.&lt;/p&gt;

&lt;h3 id=&#34;lecture-format&#34;&gt;Lecture format&lt;/h3&gt;

&lt;p&gt;I was surprised by the scarcity of within-lecture quizzes as checkpoints for the student, because I have completed several Coursera courses in which they were much more frequent (and in my mind useful). I think the course would benefit from breaking up lectures into smaller chunks with more quizzes.&lt;/p&gt;

&lt;h3 id=&#34;programming-assignments&#34;&gt;Programming assignments&lt;/h3&gt;

&lt;p&gt;The programming assignments involved filling in code skeletons in otherwise complete programs that solved some task. Again, the tasks involved seemed typically mathematical and &amp;ldquo;classic&amp;rdquo; in nature, such as anagram solving, Huffman coding and decoding, although there was also an assignment on tweet analysis.&lt;/p&gt;

&lt;h3 id=&#34;testing&#34;&gt;Testing&lt;/h3&gt;

&lt;p&gt;I appreciated that the assignments were distributed as self-contained SBT projects, along with rudimentary &lt;a href=&#34;http://junit.org/&#34;&gt;JUnit&lt;/a&gt;-style test suites, run through &lt;a href=&#34;http://www.scalatest.org/&#34;&gt;ScalaTest&lt;/a&gt; that one could add to. I get the impression that many courses on programming do not address the issue of testing at all, with the result that students flail while copying and pasting code in some IDE or REPL instead of adopting an automated testing discipline that not only decreases frustration but will prove to be a real-life practice to be used in their studies and careers.&lt;/p&gt;

&lt;p&gt;It was great to have these programming assignments distributed as complete deploy able projects. I actually looked at the non-assignment-relevant code and configurations in order to learn more about real-life SBT and Scala use for my own plans to migrate from Java to Scala at work.&lt;/p&gt;

&lt;h3 id=&#34;scala-the-language&#34;&gt;Scala the language&lt;/h3&gt;

&lt;p&gt;Scala is introduced at first as a kind of standard functional language (even though in reality Scala&amp;rsquo;s functions are actually objects). Algebraic data types are introduced through Scala&amp;rsquo;s object encoding as &lt;code&gt;case class&lt;/code&gt; in a hierarchy. I think the instructor did a good job in illustrating through example how Scala manages to blend the traditional functional and object worlds in a single language, while emphasizing the functional aspects.&lt;/p&gt;

&lt;h3 id=&#34;most-interesting&#34;&gt;Most interesting&lt;/h3&gt;

&lt;p&gt;For me, the most interesting aspect of the course and assignments was the focus on using Scala&amp;rsquo;s &amp;ldquo;for comprehension&amp;rdquo; syntactic sugar to write very concise and clear code. An entire week of lectures was focused on collections and explained how the syntactic sugar is translated into &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt;, and &lt;code&gt;filter&lt;/code&gt;. With the popularity of comprehension or similar syntax in many languages these days, I think it is very important to make sure that everyone knows that it is not just magic, but is just syntactic sugar for the important concepts that underlie it. I think the course did a good job in illustrating how comprehensions can be used not only for lists, but for many other types as well, and types that one can define oneself (Scala&amp;rsquo;s comprehension syntax is meant for any &lt;a href=&#34;http://en.wikipedia.org/wiki/Monad_(functional_programming)&#34;&gt;monad&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;update-of-2013-02-27&#34;&gt;(Update of 2013-02-27)&lt;/h4&gt;

&lt;p&gt;I just saw a good recent expository example of &lt;a href=&#34;http://tmorris.net/posts/memoisation-with-state-using-scala/index.html&#34;&gt;the use of comprehension syntax to simplify the look of code that involves writing your own monad&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I strongly recommend Martin Odersky&amp;rsquo;s &amp;ldquo;Functional Programming Principles in Scala&amp;rdquo; course to all who are interested in understanding the basics behind programming language semantics and how to apply this knowledge in writing and reasoning about clear, elegant programs to solve problems. A course like this could be taught using any number of languages as a vehicle, but I think Scala works particularly well because it is a JVM-based language that interoperates seamlessly with Java and Java&amp;rsquo;s entire tool chain, so anything you learn here, you can apply immediately in real-life work if you already operate in the JVM-based programming world. Scala is not a toy language, but is used at &lt;a href=&#34;http://twitter.github.com/scala_school/&#34;&gt;Twitter&lt;/a&gt; and many other enterprises that require reliability, performance, scalability while solving very complex problems.&lt;/p&gt;

&lt;p&gt;A final reminder: if you missed this free course the first time around, by all means check it out when it is offered again!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The start of a local Haskell study group</title>
      <link>http://franklinchen.com/blog/2012/11/05/the-start-of-a-local-haskell-study-group/</link>
      <pubDate>Mon, 05 Nov 2012 09:23:00 +0000</pubDate>
      
      <guid>http://franklinchen.com/blog/2012/11/05/the-start-of-a-local-haskell-study-group/</guid>
      <description>


&lt;figure &gt;
    
        &lt;img src=&#34;http://www.haskell.org/wikiupload/4/4a/HaskellLogoStyPreview-1.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Haskell logo&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Recently, I had a conversation with &lt;a href=&#34;http://billlaboon.com/&#34;&gt;Bill&lt;/a&gt;, who was asking about resources for learning more about functional programming. I did some serious thinking about how to advise, but eventually decided to recommend that he use the &lt;a href=&#34;http://haskell.org/&#34;&gt;Haskell&lt;/a&gt; programming language as a vehicle for getting into the theory and practice of functional programming.&lt;/p&gt;

&lt;p&gt;(To fans of &lt;a href=&#34;http://en.wikipedia.org/wiki/Standard_ML&#34;&gt;Standard ML&lt;/a&gt; or &lt;a href=&#34;http://caml.inria.fr/&#34;&gt;Caml&lt;/a&gt; or &lt;a href=&#34;http://www.scala-lang.org/&#34;&gt;Scala&lt;/a&gt; or &lt;a href=&#34;http://clojure.org/&#34;&gt;Clojure&lt;/a&gt; or &lt;a href=&#34;http://racket-lang.org/&#34;&gt;Racket&lt;/a&gt; or other languages: I will explain my rationale later.)&lt;/p&gt;

&lt;p&gt;Also, I recommended a particular tutorial as a decent starting point: a book available online called &lt;a href=&#34;http://learnyouahaskell.com/&#34;&gt;&amp;ldquo;Learn You a Haskell for Great Good!&amp;rdquo;&lt;/a&gt; (seriously).&lt;/p&gt;

&lt;p&gt;As &lt;a href=&#34;http://billlaboon.com/learning-myself-a-haskell-for-great-good/&#34;&gt;Bill got going&lt;/a&gt; and &lt;a href=&#34;http://www.chrisumbel.com/&#34;&gt;Chris&lt;/a&gt; joined us, Bill set up a Google Group to make discussion easier. If you&amp;rsquo;re interested in joining the study group, let us know!&lt;/p&gt;

&lt;h2 id=&#34;a-project-setup&#34;&gt;A project setup&lt;/h2&gt;

&lt;p&gt;Meanwhile, one of my first suggestions so far to the participants has been to get a decent serious development setup beyond just using the REPL for experimentation. In particular, as a proponent of &lt;a href=&#34;http://en.wikipedia.org/wiki/Test-driven_development&#34;&gt;Test-Driven Development&lt;/a&gt;, I believe that anyone learning a new programming language should be given the tools to immediately get a serious process going, even if only to solve trivial problems.&lt;/p&gt;

&lt;p&gt;Since &lt;a href=&#34;http://projecteuler.net/&#34;&gt;Project Euler&lt;/a&gt; was brought up as a source of little programming exercises to solve, I decided to create a project structure with (currently) one solved problem and a test file using &lt;a href=&#34;http://hunit.sourceforge.net/&#34;&gt;HUnit&lt;/a&gt; and &lt;a href=&#34;http://batterseapower.github.com/test-framework/&#34;&gt;test-framework&lt;/a&gt; as a template one can use to set up a complete development process.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the link to my &lt;a href=&#34;http://github.com/FranklinChen/project-euler-haskell&#34;&gt;&lt;code&gt;project-euler-haskell&lt;/code&gt; on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Comments and participation are welcome!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Revisiting Knuth and McIlroy&#39;s word count programs</title>
      <link>http://franklinchen.com/blog/2011/12/08/revisiting-knuth-and-mcilroys-word-count-programs/</link>
      <pubDate>Thu, 08 Dec 2011 21:46:00 +0000</pubDate>
      
      <guid>http://franklinchen.com/blog/2011/12/08/revisiting-knuth-and-mcilroys-word-count-programs/</guid>
      <description>&lt;p&gt;Today I came across a &lt;a href=&#34;http://www.leancrew.com/all-this/2011/12/more-shell-less-egg/&#34;&gt;blog post&lt;/a&gt; revisiting &lt;a href=&#34;http://en.wikipedia.org/wiki/Jon_Bentley&#34;&gt;Jon Bentley&lt;/a&gt;&amp;rsquo;s challenge in 1986 to &lt;a href=&#34;http://www-cs-staff.stanford.edu/~uno/&#34;&gt;Donald Knuth&lt;/a&gt; to write a &lt;a href=&#34;http://en.wikipedia.org/wiki/Literate_programming&#34;&gt;literate program&lt;/a&gt; to solve a sample task and have &lt;a href=&#34;http://www.cs.dartmouth.edu/~doug/&#34;&gt;Doug McIlroy&lt;/a&gt; critique it.&lt;/p&gt;

&lt;p&gt;The task:&lt;/p&gt;

&lt;blockquote&gt;
Read a file of text, determine the n most frequently used words, and print out a sorted list of those words along with their frequencies.
&lt;/blockquote&gt;

&lt;p&gt;Knuth came up with a typically clever, lengthy, low-level implementation. McIlroy then somewhat perversely wrote a six-line shell script that did the job, basically changing the subject away from literate programming and toward a &lt;a href=&#34;http://www.princeton.edu/~hos/mike/transcripts/mcilroy.htm&#34;&gt;critique of Knuth&amp;rsquo;s doing something low-level and complicated when unnecessary&lt;/a&gt;. The article publishing both Knuth&amp;rsquo;s and McIlroy&amp;rsquo;s solutions is &lt;a href=&#34;http://dl.acm.org/citation.cfm?id=315654&#34;&gt;available here&lt;/a&gt;. A followup article with David Hanson&amp;rsquo;s implementation in C is &lt;a href=&#34;http://www.cs.upc.edu/~eipec/pdf/p583-van_wyk.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I decided to bring the discussion here a quarter of a century (25 years!) to the present. How would we solve the problem now?&lt;/p&gt;

&lt;h2 id=&#34;update-of-2013-06-29&#34;&gt;(Update of 2013-06-29)&lt;/h2&gt;

&lt;p&gt;I have changed my mind about many things I said here, and also have more clarifications and new arguments to make, which I will eventually post on my new programming blog, &lt;a href=&#34;http://ConscientiousProgrammer.com/&#34;&gt;The Conscientious Programmer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;salient-points-of-mcilroy-s-solution&#34;&gt;Salient points of McIlroy&amp;rsquo;s solution&lt;/h2&gt;

&lt;p&gt;First, let&amp;rsquo;s look at McIlroy&amp;rsquo;s solution, which despite the passing of time is still a beautifully elegant illustration of why &lt;a href=&#34;../../blog/2011/10/13/why-dennis-ritchie-is-important/&#34;&gt;Unix is timeless&lt;/a&gt;. (By the way, &lt;a href=&#34;http://www.informit.com/articles/article.aspx?p=1193856&#34;&gt;Knuth is a C and Linux user to this day&lt;/a&gt;).&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;tr -cs A-Za-z &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt; |
tr A-Z a-z |
sort |
uniq -c |
sort -rn |
sed &lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color: #19177C&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #BB6688; font-weight: bold&#34;&gt;}&lt;/span&gt;q
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code is self-explanatory if you are familiar with basic Unix command-line tools. The pipeline just transforms data starting from standard input until the desired result is computed.&lt;/p&gt;

&lt;p&gt;What is beautiful about the code is that it decomposes the solution to intuitively and does not require any mutable state. McIlroy&amp;rsquo;s program is a &lt;a href=&#34;http://en.wikipedia.org/wiki/Purely_functional&#34;&gt;purely functional&lt;/a&gt; program.&lt;/p&gt;

&lt;h2 id=&#34;using-a-general-purpose-programming-language-instead&#34;&gt;Using a general-purpose programming language instead&lt;/h2&gt;

&lt;p&gt;I thought to myself, how would I write the program today? Especially if I thought I would need to modify it, add new features? The shell script does the job for the problem as stated, but would clearly be hard to extend. Indeed, historically, &amp;ldquo;scripting languages&amp;rdquo; such as &lt;a href=&#34;http://en.wikipedia.org/wiki/AWK&#34;&gt;Awk&lt;/a&gt; were invented in order to do more than simple shell scripts were suitable for, and &lt;a href=&#34;http://www.perl.org/&#34;&gt;Perl&lt;/a&gt; was Larry Wall&amp;rsquo;s response to Awk, to create a truly general-purpose language.&lt;/p&gt;

&lt;p&gt;Nowadays, in 2011, languages and libraries are at a sufficiently high level that a program almost as concise as McIlroy&amp;rsquo;s could be written in Perl, Ruby, Python, or even the latest versions of Java, C#, etc. I&amp;rsquo;ll leave that as an exercise for you (feel free to post your solutions as comments below).&lt;/p&gt;

&lt;h3 id=&#34;haskell&#34;&gt;Haskell&lt;/h3&gt;

&lt;p&gt;I present a simple program in &lt;a href=&#34;http://www.haskell.org/&#34;&gt;Haskell&lt;/a&gt; that I feel is closest to McIlroy&amp;rsquo;s both in spirit and in letter.&lt;/p&gt;

&lt;p&gt;Here is my Haskell program, in two variants. The first is a standard source code file, while the second uses Haskell&amp;rsquo;s built-in support for its own notion of &amp;ldquo;literate programming&amp;rdquo;.&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/1448622.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;I used &lt;a href=&#34;http://www.haskell.org/ghc/&#34;&gt;GHC&lt;/a&gt; to compile and run the program.  Sample output:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; ghc -O6 --make WordCount
&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; ./WordCount &lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt; &amp;lt; WordCount.lhs
&lt;span style=&#34;color: #888888&#34;&gt;35 the&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;16 a&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;11 list&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;10 of&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;9 text&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;9 for&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;8 n&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;8 map&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;8 count&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;7 string&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Apart from missing leading spaces, this is the same output as from McIlroy&amp;rsquo;s shell script.&lt;/p&gt;

&lt;p&gt;The literate program above explains each step of the Haskell &amp;ldquo;pipeline&amp;rdquo; I constructed.&lt;/p&gt;

&lt;h2 id=&#34;why-i-don-t-do-literate-programming&#34;&gt;Why I don&amp;rsquo;t do literate programming&lt;/h2&gt;

&lt;p&gt;I don&amp;rsquo;t currently use &amp;ldquo;literate programming&amp;rdquo; systems.&lt;/p&gt;

&lt;p&gt;I experimented with programming in C and C++ and &lt;a href=&#34;http://en.wikipedia.org/wiki/Standard_ML&#34;&gt;Standard ML&lt;/a&gt; using &lt;a href=&#34;http://www.cs.tufts.edu/~nr/noweb/&#34;&gt;noweb&lt;/a&gt; over a decade ago, but found that for myself, it was not really beneficial.&lt;/p&gt;

&lt;p&gt;There was little benefit in being able to rearrange code fragments at will. Furthermore, spreading code out interspersed with a lot of prose made it harder for me to actually &lt;a href=&#34;http://en.wikipedia.org/wiki/Chunking_(psychology)&#34;&gt;chunk&lt;/a&gt; meaning out of a spatial portion of text in my editor window.&lt;/p&gt;

&lt;p&gt;Also, modern languages and programming styles make it much easier to express things concisely and less monolithically, such that I find that using ordinary comments suffices for my needs.&lt;/p&gt;

&lt;p&gt;I find that literate programming in the Knuth style amounts to a macro system that distorts the layout of code.&lt;/p&gt;

&lt;p&gt;Finally, literate programming interacts badly with editors and IDEs that are built specifically to operate on pure source code.&lt;/p&gt;

&lt;p&gt;What do you think? Which of the variants of the same Haskell code above would you prefer to write, read, or maintain? The non-literate one or the literate one?&lt;/p&gt;

&lt;h2 id=&#34;an-alternative-to-literate-programming&#34;&gt;An alternative to literate programming&lt;/h2&gt;

&lt;p&gt;I should note that in practice, I would write suitable comments in a non-literate program primarily before the function definition. Also, I would not use such a large pipeline of expressions either: I would break out almost every line of the pipeline into its own little function, with its own comment. That is how I would actually write a nontrivial Haskell program, writing one or two line functions and testing each of them, before trying to hook them all up into a big pipeline.&lt;/p&gt;

&lt;p&gt;I &amp;ldquo;cheated&amp;rdquo; in this case because McIlroy&amp;rsquo;s program already existed, so I simply translated it into a Haskell equivalent without real thought and testing.&lt;/p&gt;

&lt;h2 id=&#34;comparison-between-the-shell-script-and-the-haskell-program&#34;&gt;Comparison between the shell script and the Haskell program&lt;/h2&gt;

&lt;p&gt;The shell script operates on raw text and everything is just strings being parsed and reparsed by the respective Unix utility programs.&lt;/p&gt;

&lt;p&gt;The Haskell program is &lt;em&gt;statically typed&lt;/em&gt;. It is type-checked by the compiler, which generates native code. The program uses standard libraries and data types, such as lists and hash maps.&lt;/p&gt;

&lt;p&gt;Also, the Haskell program could be refined, extended, optimized in various ways. The most important optimizations I can think of off the top of my head:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Using a better representation of strings than the default built-in &amp;ldquo;string as list of characters&amp;rdquo;. Easily accessible advice can be found on &lt;a href=&#34;http://stackoverflow.com/questions/576213/efficient-string-implementation-in-haskell&#34;&gt;Stack Overflow&lt;/a&gt; and browsing through Haskell library documentation, such as for the &lt;a href=&#34;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text&#34;&gt;text&lt;/a&gt; package.&lt;/li&gt;
&lt;li&gt;Loop fusion, &lt;a href=&#34;http://en.wikipedia.org/wiki/Deforestation_(computer_science)&#34;&gt;deforestation&lt;/a&gt; can be applied to deal with the &lt;em&gt;apparent&lt;/em&gt; allocation of lots of new lists in the pipeline. One of the selling points of using a language like Haskell is the opportunity for the compiler to perform radical optimizations that are impossible for languages that have side effects.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I don&amp;rsquo;t write many &lt;code&gt;bash&lt;/code&gt; scripts these days. General-purpose programming languages can do a decent job munging data without difficulty. The situation was different decades ago when there was C, and few standard high-level libraries for the C world.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;I am skeptical of literate programming.&lt;/li&gt;
&lt;li&gt;McIlroy was ahead of his time, but that time has passed; we should take his contributions as inspiration to move further forward already, using advanced general-purpose programming languages.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>